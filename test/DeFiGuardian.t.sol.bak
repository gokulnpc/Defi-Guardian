// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Test, console2} from "forge-std/Test.sol";
import {Deployer} from "./Deployer.sol";
import {MockCCIPRouter} from "./mocks/MockCCIPRouter.sol";
import {MockPYUSD} from "./mocks/MockPYUSD.sol";
import {IPremiumVault} from "./interfaces/IPremiumVault.sol";
import {ILPVault} from "./interfaces/ILPVault.sol";
import {IPayoutVault} from "./interfaces/IPayoutVault.sol";
import {IPolicyManager} from "./interfaces/IPolicyManager.sol";
import {IVotingMirror} from "./interfaces/IVotingMirror.sol";
import {IClaimManager} from "./interfaces/IClaimManager.sol";
import {Client} from "../contracts/PremiumVault.sol";

contract DeFiGuardianTest is Test {
    Deployer public deployer;
    MockCCIPRouter public mockRouter;
    MockPYUSD public pyusd;

    // Arbitrum contracts
    address public premiumVault;
    address public lpVault;
    address public payoutVault;
    address public policyManager;

    // Hedera contracts
    address public votingMirror;
    address public claimManager;

    // Test addresses
    address public alice = address(0x1);
    address public bob = address(0x2);
    address public charlie = address(0x3);
    address public owner = address(0x4);

    // Test constants
    uint256 public constant PREMIUM_AMOUNT = 1000e6; // 1000 PYUSD (6 decimals)
    uint256 public constant COVERAGE_AMOUNT = 10000e6; // 10000 PYUSD coverage
    uint256 public constant LP_DEPOSIT = 5000e6; // 5000 PYUSD LP deposit

    function setUp() public {
        // Deploy mock contracts
        mockRouter = new MockCCIPRouter();
        pyusd = new MockPYUSD();

        // Deploy main contracts
        deployer = new Deployer();
        (
            premiumVault,
            lpVault,
            payoutVault,
            policyManager,
            votingMirror,
            claimManager
        ) = deployer.deployAll(
            address(mockRouter),
            address(pyusd),
            owner
        );

        // Fund test accounts
        pyusd.mint(alice, 10000e6);
        pyusd.mint(bob, 10000e6);
        pyusd.mint(charlie, 10000e6);

        // Setup CCIP allowlists
        _setupCCIPAllowlists();
    }

    function _setupCCIPAllowlists() internal {
        // Allow Arbitrum -> Hedera communication
        vm.prank(owner);
        IPolicyManager(policyManager).allowlistSourceChain(1, true); // Arbitrum selector
        vm.prank(owner);
        IPolicyManager(policyManager).allowlistSender(abi.encode(premiumVault), true);

        // Allow Hedera -> Arbitrum communication
        vm.prank(owner);
        IPayoutVault(payoutVault).allowlistSourceChain(2, true); // Hedera selector
        vm.prank(owner);
        IPayoutVault(payoutVault).allowlistSender(abi.encode(claimManager), true);

        // Setup LP sync allowlists
        vm.prank(owner);
        IVotingMirror(votingMirror).allowlistSourceChain(1, true);
        vm.prank(owner);
        IVotingMirror(votingMirror).allowlistSender(abi.encode(lpVault), true);
    }

    // ============ PREMIUM FLOW TESTS ============

    function test_BuyCoverage() public {
        vm.startPrank(alice);

        // Approve PYUSD spending
        pyusd.approve(premiumVault, PREMIUM_AMOUNT);

        // Buy coverage
        IPremiumVault.PolicyTerms memory terms = IPremiumVault.PolicyTerms({
            poolId: "POOL_001",
            coverageAmount: COVERAGE_AMOUNT,
            startTs: uint64(block.timestamp),
            endTs: uint64(block.timestamp + 30 days),
            policyRef: "POLICY_REF_001"
        });
        
        bytes32 policyId = IPremiumVault(premiumVault).buyCoverage{value: 0.1 ether}(
            1, // destination chain selector (Hedera)
            abi.encode(policyManager), // hedera receiver
            terms,
            PREMIUM_AMOUNT
        );

        // Verify policy was created
        assertTrue(policyId != bytes32(0), "Policy ID should not be zero");

        // Verify PYUSD was transferred
        assertEq(pyusd.balanceOf(premiumVault), PREMIUM_AMOUNT, "Premium should be in vault");
        assertEq(pyusd.balanceOf(alice), 9000e6, "Alice should have paid premium");

        vm.stopPrank();
    }

    function test_PremiumAllocation() public {
        vm.startPrank(alice);

        // Approve and buy coverage
        pyusd.approve(premiumVault, PREMIUM_AMOUNT);
        IPremiumVault(premiumVault).buyCoverage{value: 0.1 ether}(
            1,
            "POOL_001",
            COVERAGE_AMOUNT,
            uint64(block.timestamp),
            uint64(block.timestamp + 30 days),
            "POLICY_REF_001"
        );

        vm.stopPrank();

        // Check premium allocation (70% to LP, 30% to reserve)
        (uint256 toLP, uint256 toReserve) = IPremiumVault(premiumVault).previewAllocation(PREMIUM_AMOUNT);
        
        assertEq(toLP, 700e6, "70% should go to LP");
        assertEq(toReserve, 300e6, "30% should go to reserve");
    }

    // ============ LP FLOW TESTS ============

    function test_LPDeposit() public {
        vm.startPrank(bob);

        // Approve PYUSD spending
        pyusd.approve(lpVault, LP_DEPOSIT);

        // Deposit as LP
        uint256 shares = ILPVault(lpVault).deposit(LP_DEPOSIT);

        // Verify shares were minted
        assertGt(shares, 0, "Shares should be minted");
        assertEq(ILPVault(lpVault).totalShares(), shares, "Total shares should match");

        // Verify PYUSD was transferred
        assertEq(pyusd.balanceOf(lpVault), LP_DEPOSIT, "LP vault should have PYUSD");

        vm.stopPrank();
    }

    function test_LPWithdrawal() public {
        vm.startPrank(bob);

        // Deposit as LP
        pyusd.approve(lpVault, LP_DEPOSIT);
        uint256 shares = ILPVault(lpVault).deposit(LP_DEPOSIT);

        // Request withdrawal
        ILPVault(lpVault).requestWithdraw(shares);

        // Fast forward past cooldown
        vm.warp(block.timestamp + 1 days + 1);

        // Finalize withdrawal
        ILPVault(lpVault).finalizeWithdraw();

        // Verify withdrawal
        assertEq(ILPVault(lpVault).totalShares(), 0, "Total shares should be zero");
        assertEq(pyusd.balanceOf(bob), 10000e6, "Bob should have PYUSD back");

        vm.stopPrank();
    }

    // ============ CROSS-CHAIN GOVERNANCE TESTS ============

    function test_LPVotingPowerSync() public {
        vm.startPrank(bob);

        // Deposit as LP
        pyusd.approve(lpVault, LP_DEPOSIT);
        ILPVault(lpVault).deposit(LP_DEPOSIT);

        vm.stopPrank();

        // Simulate CCIP message from Arbitrum to Hedera
        bytes memory payload = abi.encode(
            bob, // LP address
            LP_DEPOSIT, // shares
            block.timestamp + 1 days // locked until
        );

        // Mock CCIP receive on Hedera
        vm.prank(address(mockRouter));
        IVotingMirror(votingMirror).ccipReceive(
            abi.encode(
                bytes32(0x1), // messageId
                1, // sourceChainSelector (Arbitrum)
                abi.encode(lpVault), // sender
                payload, // data
                new address[](0), // destTokenAmounts (empty)
                new uint256[](0)
            )
        );

        // Verify voting power was set
        assertEq(IVotingMirror(votingMirror).vPowerOf(bob), LP_DEPOSIT, "Voting power should match LP deposit");
    }

    function test_PolicyRegistration() public {
        vm.startPrank(alice);

        // Buy coverage
        pyusd.approve(premiumVault, PREMIUM_AMOUNT);
        bytes32 policyId = IPremiumVault(premiumVault).buyCoverage{value: 0.1 ether}(
            1,
            "POOL_001",
            COVERAGE_AMOUNT,
            uint64(block.timestamp),
            uint64(block.timestamp + 30 days),
            "POLICY_REF_001"
        );

        vm.stopPrank();

        // Simulate CCIP message from Arbitrum to Hedera
        bytes memory payload = abi.encode(
            IPolicyManager.PolicyTerms({
                poolId: "POOL_001",
                buyer: alice,
                coverageAmount: COVERAGE_AMOUNT,
                startTs: uint64(block.timestamp),
                endTs: uint64(block.timestamp + 30 days),
                policyRef: "POLICY_REF_001"
            })
        );

        // Mock CCIP receive on Hedera
        vm.prank(address(mockRouter));
        IPolicyManager(policyManager).ccipReceive(
            Client.Any2EVMMessage({
                messageId: bytes32(0x2),
                sourceChainSelector: 1, // Arbitrum
                sender: abi.encode(premiumVault),
                data: payload,
                destTokenAmounts: new Client.EVMTokenAmount[](0)
            })
        );

        // Verify policy was registered
        IPolicyManager.Policy memory policy = IPolicyManager(policyManager).getPolicy(policyId);
        assertEq(policy.buyer, alice, "Policy buyer should match");
        assertEq(policy.coverageAmount, COVERAGE_AMOUNT, "Coverage amount should match");
        assertTrue(policy.active, "Policy should be active");
    }

    // ============ CLAIMS FLOW TESTS ============

    function test_ClaimVoting() public {
        // Setup: Create policy and LP
        _setupPolicyAndLP();

        // Create claim
        vm.startPrank(alice);
        IClaimManager(claimManager).openClaim(
            "POOL_001",
            alice,
            5000e6, // claim amount
            1, // destination chain selector (Arbitrum)
            abi.encode(payoutVault)
        );
        vm.stopPrank();

        uint256 claimId = 1; // First claim

        // Vote on claim
        vm.startPrank(bob);
        IClaimManager(claimManager).voteYes(claimId);
        vm.stopPrank();

        vm.startPrank(charlie);
        IClaimManager(claimManager).voteNo(claimId);
        vm.stopPrank();

        // Fast forward past voting period
        vm.warp(block.timestamp + 6 minutes);

        // Finalize claim
        vm.prank(alice);
        IClaimManager(claimManager).finalizeClaim{value: 0.1 ether}(claimId);

        // Verify claim was processed
        IClaimManager.Claim memory claim = IClaimManager(claimManager).claims(claimId);
        assertTrue(claim.finalized, "Claim should be finalized");
    }

    function test_ClaimPayout() public {
        // Setup: Create policy and LP
        _setupPolicyAndLP();

        // Fund payout vault
        vm.startPrank(owner);
        pyusd.approve(payoutVault, 10000e6);
        IPayoutVault(payoutVault).depositPYUSD(10000e6);
        vm.stopPrank();

        // Create and approve claim
        vm.startPrank(alice);
        IClaimManager(claimManager).openClaim(
            "POOL_001",
            alice,
            5000e6,
            1,
            abi.encode(payoutVault)
        );
        vm.stopPrank();

        uint256 claimId = 1;

        // Vote to approve
        vm.startPrank(bob);
        IClaimManager(claimManager).voteYes(claimId);
        vm.stopPrank();

        vm.startPrank(charlie);
        IClaimManager(claimManager).voteYes(claimId);
        vm.stopPrank();

        // Fast forward and finalize
        vm.warp(block.timestamp + 6 minutes);
        vm.prank(alice);
        IClaimManager(claimManager).finalizeClaim{value: 0.1 ether}(claimId);

        // Simulate CCIP payout message from Hedera to Arbitrum
        bytes memory payoutPayload = abi.encode(
            bytes32(0x1), // TAG_PAYOUT_V1
            claimId,
            alice,
            5000e6
        );

        // Mock CCIP receive on Arbitrum
        vm.prank(address(mockRouter));
        IPayoutVault(payoutVault).ccipReceive(
            Client.Any2EVMMessage({
                messageId: bytes32(0x3),
                sourceChainSelector: 2, // Hedera
                sender: abi.encode(claimManager),
                data: payoutPayload,
                destTokenAmounts: new Client.EVMTokenAmount[](0)
            })
        );

        // Verify payout was executed
        assertEq(pyusd.balanceOf(alice), 14000e6, "Alice should receive payout"); // 9000 + 5000
    }

    // ============ HELPER FUNCTIONS ============

    function _setupPolicyAndLP() internal {
        // Alice buys coverage
        vm.startPrank(alice);
        pyusd.approve(premiumVault, PREMIUM_AMOUNT);
        IPremiumVault(premiumVault).buyCoverage{value: 0.1 ether}(
            1,
            "POOL_001",
            COVERAGE_AMOUNT,
            uint64(block.timestamp),
            uint64(block.timestamp + 30 days),
            "POLICY_REF_001"
        );
        vm.stopPrank();

        // Bob and Charlie become LPs
        vm.startPrank(bob);
        pyusd.approve(lpVault, LP_DEPOSIT);
        ILPVault(lpVault).deposit(LP_DEPOSIT);
        vm.stopPrank();

        vm.startPrank(charlie);
        pyusd.approve(lpVault, LP_DEPOSIT);
        ILPVault(lpVault).deposit(LP_DEPOSIT);
        vm.stopPrank();

        // Sync LP voting power to Hedera
        _syncLPVotingPower();
    }

    function _syncLPVotingPower() internal {
        // Mock CCIP messages for LP sync
        bytes memory bobPayload = abi.encode(bob, LP_DEPOSIT, block.timestamp + 1 days);
        bytes memory charliePayload = abi.encode(charlie, LP_DEPOSIT, block.timestamp + 1 days);

        vm.prank(address(mockRouter));
        IVotingMirror(votingMirror).ccipReceive(
            Client.Any2EVMMessage({
                messageId: bytes32(0x4),
                sourceChainSelector: 1,
                sender: abi.encode(lpVault),
                data: bobPayload,
                destTokenAmounts: new Client.EVMTokenAmount[](0)
            })
        );

        vm.prank(address(mockRouter));
        IVotingMirror(votingMirror).ccipReceive(
            Client.Any2EVMMessage({
                messageId: bytes32(0x5),
                sourceChainSelector: 1,
                sender: abi.encode(lpVault),
                data: charliePayload,
                destTokenAmounts: new Client.EVMTokenAmount[](0)
            })
        );
    }

    // ============ EDGE CASES & ERROR TESTS ============

    function test_RevertWhenInsufficientBalance() public {
        vm.startPrank(alice);
        
        // Try to buy coverage without enough PYUSD
        pyusd.approve(premiumVault, PREMIUM_AMOUNT);
        vm.expectRevert();
        IPremiumVault(premiumVault).buyCoverage{value: 0.1 ether}(
            1,
            "POOL_001",
            COVERAGE_AMOUNT,
            uint64(block.timestamp),
            uint64(block.timestamp + 30 days),
            "POLICY_REF_001"
        );
        
        vm.stopPrank();
    }

    function test_RevertWhenNotAllowlisted() public {
        // Try to send CCIP message from non-allowlisted sender
        bytes memory payload = abi.encode("test");
        
        vm.prank(address(mockRouter));
        vm.expectRevert();
        IPolicyManager(policyManager).ccipReceive(
            Client.Any2EVMMessage({
                messageId: bytes32(0x6),
                sourceChainSelector: 1,
                sender: abi.encode(address(0x999)), // Non-allowlisted
                data: payload,
                destTokenAmounts: new Client.EVMTokenAmount[](0)
            })
        );
    }

    function test_RevertDuplicateMessage() public {
        bytes memory payload = abi.encode("test");
        
        // Send first message
        vm.prank(address(mockRouter));
        IPolicyManager(policyManager).ccipReceive(
            Client.Any2EVMMessage({
                messageId: bytes32(0x7),
                sourceChainSelector: 1,
                sender: abi.encode(premiumVault),
                data: payload,
                destTokenAmounts: new Client.EVMTokenAmount[](0)
            })
        );

        // Try to send same message again
        vm.prank(address(mockRouter));
        vm.expectRevert();
        IPolicyManager(policyManager).ccipReceive(
            Client.Any2EVMMessage({
                messageId: bytes32(0x7), // Same message ID
                sourceChainSelector: 1,
                sender: abi.encode(premiumVault),
                data: payload,
                destTokenAmounts: new Client.EVMTokenAmount[](0)
            })
        );
    }
}
